---
title: "`<said>` Element"
description: |
  Who says what and to whom...
author:
  - name: Mathieu Glachant
    url: {}
date: 2022-10-04
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(XML)
library(skimr)
library(gt)

xml_path = "../../../DigitalTerraIgnota/output/said.xml"
csv_path = "../../data/said.csv"

```

## Origins of This Data

This data is generated by extracting all `<said>` nodes in the Digital Edition of _Terra Ignota_.

### What Are `<said>` Nodes For?

The Digital Edition uses __TEI__ `<said>` nodes to mark up passages of the text that represent direct communication between characters. Information about such passages beyond their contents is encoded in various ways, see the [data dictionary](#making-sense-of-the-data) below for the origin of every piece of data provided.

### Example Nodes

I usually refer to such passages as a 'line of dialog' or 'line' for short. A line between Mycroft and Dominic would be encoded thus:

#### Novel Layout
```xml
<p>
  <said>"Where hast thou been, stray?"</said>, Dominic snarled.
</p>
```

#### Script Layout
```xml
<sp>
  <speaker>Child:</speaker>
  <said>"I miss you, Mycroft."</said>
</sp>
```

Note that the narration part of that paragraph is always left outside of the `<said>` node.

## Get the Data

The data extracted from the Digital Edition's `<said>` nodes is available as a CSV file.

### Download Link

<div style="text-align: right">[Download the data](`r csv_path`)<br></div>

### Last Updated

This file was last updated on `r Sys.Date()`.

## Raw Data Generation

The raw data is extracted from the `<said>` nodes in the Digital Edition stored in a separate private repo using the following Xquery script.

### Xquery Script

For easy ingestion with the `XML` package in R, we generate a `<records>` root node and one `<line>` node per line of dialog in the original text.

The Xquery script first two levels of nodes therefore look like this:

```xml
xquery version "3.1";

declare namespace tei = "http://www.tei-c.org/ns/1.0";
declare variable $doc := doc("PATH_TO_TEI_FILE");

<records>
  {for $line at $index in $doc/tei:TEI/tei:text/tei:group/tei:text/tei:body//tei:said
  return 
  <line>
    ...
    A node per column in the out file, see data dictionary for details
    ...
  </line>}
</records>
```

`$doc/tei:TEI/tei:text/tei:group/tei:text/tei:body//tei:said` is an Xpath expression that selects all of the `<said>` nodes in the body (i.e. excluding the fore- and back-matter) of any of the novels in the series.

See the [data dictionary](#making-sense-of-the-data) below for the Xquery used to retrieve each column.

### XML Output File

The output is an xml output file of the form: 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<records>
   <line>
      <book>1</book>
      <chapter>1</chapter>
      <page>13</page>
      <line>1</line>
      <speaker>#Mycroft</speaker>
      <addressee>#reader</addressee>
      <person>#reader</person>
      <org>NA</org>
      <place>NA</place>
      <language>en-en</language>
      <aloud>FALSE</aloud>
      <format>novel</format>
      <text>You will criticize me, reader, for ... </text>
   </line>
   
   etc...
   
</records>
```

## Data Cleaning

The XML output file generated by Xquery is then cleaned, tidied, and purged of content under copyright before being saved to the csv file provided above.

### Step 1: Fix Data Types and _NA_ Values

First, the correct data types must be set for each column and missing values set to _NA_.

```{r data_cleanup, echo=TRUE}
said <- xmlToDataFrame(xml_path) %>%
  # Column data types must be correct, missing values must be _NA_
  mutate(
    book = as.integer(book),
    chapter = as.integer(chapter),
    page = as.integer(page),
    line = as.integer(line),
    speaker = na_if(speaker, "NA"),
    addressee = na_if(addressee, "NA"),
    person = na_if(person, "NA"),
    org = na_if(org, "NA"),
    place = na_if(place, "NA"),
    aloud = as.logical(aloud)
    )
```

NB: I'm using the `XML` and `tidyverse` packages here.

### Step 2: Separate Delimited Lists Into Rows

Second, any rows containing delimited lists, e.g. a line of dialog with more than one addressee, must be^[In order to be _Tidy Data_, in which each row represents a single observation.] separated into one row per item in the list.

```{r data-tidy, echo=TRUE}
said <- said %>%
  # Break space-delimited columns across multiple rows
  separate_rows(speaker, sep = " ") %>%
  separate_rows(addressee, sep = " ") %>%
  separate_rows(person, sep = " ") %>%
  separate_rows(org, sep = " ") %>%
  separate_rows(place, sep = " ") 
```

NB: In the xml output files the lists are space-delimited, since they derive from xml node parameters.

After this operation, the `r said %>% group_by(line) %>% summarize(n = n()) %>% nrow()` lines of dialog in the text are represented as `r said %>% nrow()` rows in the data.

### Step 3: Remove Raw Text

Lastly, before writing to the CSV file, remove text under copyright. Last chance to do anything with the raw text, so we add a `words` column for the number of words in the line.

```{r respect_copyright, echo=TRUE}

said <- said %>%
  # Proxy for word count, counting spaces as separators
  mutate(words = str_count(text, " ") + 1)  %>%
  # Must not include the original text for copyright reasons
  mutate(text = NULL)
```

```{r write_csv}
said %>%
  write_csv(csv_path)
```

NB: If you have ideas for other columns I could generate from the text at this steps, please create an issue in the tracker [here](https://github.com/syvwlch/Data-Ignota/issues), or start a new discussion [here](https://github.com/syvwlch/Data-Ignota/discussions).

## Editing Progress

I track progress as the percentage of the lines in a chapter that have at least a `speaker` value. I also report the number of lines of dialog still missing a `speaker` or `addressee` value, so I can go back to the Digital Edition and fix them.

### Too Like the Lighting

```{r editing_progress, echo=FALSE, message=FALSE, warning=FALSE}
progress <- said %>% 
  filter(book == 1) %>%
  nest(addressee, person, org, place) %>%
  select(chapter, speaker) %>%
  group_by(chapter) %>%
  skim(speaker) %>%
  filter(complete_rate > 0) %>%
  summarize(chapter, Progress = complete_rate, Speaker = n_missing)

progress <- progress %>%
  left_join(
    said %>%
      nest(speaker, person, org, place) %>%
      select(chapter, addressee) %>%
      group_by(chapter) %>% 
      skim(addressee) %>% 
      summarize(chapter, Addressee = n_missing)
  )

progress %>%
  gt(rowname_col = "chapter") %>%
  tab_header(
    title = "Too Like the Lightning",
    subtitle = md("_Editing Progress_")
  ) %>%
  opt_align_table_header(align = "left") %>%
  tab_stubhead(label = "Chapter") %>%
  tab_spanner(
    label = md("_Missing_"),
    columns = c(Speaker, Addressee)
  ) %>%
  fmt_percent(Progress, decimals = 0,) %>%
  sub_zero(zero_text = "-") %>%
  cols_label(
    Speaker = md("`speaker`"),
    Addressee = md("`addressee`")
  ) %>%
  opt_row_striping()

```

## Making Sense of the Data

What follows is a data dictionary, explaining each column of the file: how it is generated and what it means.

### `book`

The number of the book containing the line.

Required, numeric.

Derived from parameter `n` of the `<text type="book">` node the line is a child of.

```xml
<book>
  {data($line/ancestor::tei:text[@type = "book"]/@n)}
</book>
```

### `chapter`

The number of the chapter containing the line.

Required, numeric.

Derived from parameter `n` of the `<div type="chapter">` node the line is a child of.

```xml
<chapter>
  {data($line/ancestor::tei:div/@n)}
</chapter>
```

### `page`

The number of the page on which the line starts.

Required, numeric.

Derived from parameter `n` of the `<pb/>` milestone node which precedes the line in document order.

```xml
<page>
  {data($line/preceding::tei:pb[1]/@n)}
</page>
```

### `line`

The number of the actual line of dialog in the original text, unique across all four books.

Required, numeric.

If it is important to count or visualize the data by lines in the original text, the data should be nested first by the columns from `speaker` to `place`.

```xml
<line>
  {$index}
</line>
```

NB: The `line` value is assigned dynamically by the Xquery when the file is generated, not embedded in the text as markup. Therefore it can change between releases.

### `speaker`

The unique identifier of the character speaking the line. 

Required, `NA` indicates the line has not been edited^[That is, the editor has not gotten to that part of the text or has missed a line.].

Derived from parameter `Who` of the line's `<said>` node, broken out to multiple rows if it contained a space-delimited list of values.

```xml
<speaker>
  {if ($line/@who) then data($line/@who) else "NA"}
</speaker>
```

#### Character IDs

The identifier takes the form `#Mycroft` or `#Carlyle`. It points to a unique `<person>` node with the `xml:id` parameter set to that value.

Those `<person>` nodes contain metadata about the character, e.g. names, affiliations, age, etc... and are stored outside the text in a `<standoff>` node within the Digital Edition's file.

I will, at some point, publish the list of characters as its own file and the primary key will be this identifier to permit joins.

#### 'Unknown' Characters

It is not always clear in the text who is speaking, e.g. when Carlyle first overhears thru Thisbe's door in Chapter the First, or the speaker is an unnamed individual in a crowd or group, e.g. the several services who witness Vivien dragging Mycroft out of the gutter in Chapter the Sixth.

For such cases, I use generic IDs with  the form `#Unknown-Soldier` or `#Unknown-Servicer` or the fallback `#Unknown`.

### `addressee`

The unique identifier of the character the line is being spoken to. 

Required, `NA` indicates the line has not been edited.

Derived from the parameter `toWhom` of the line's `<said>` node, broken out to multiple rows if it contained a space-delimited list of values. See `speaker` for format and meaning of the identifier.

```xml
<addressee>
  {if ($line/@toWhom) then data($line/@toWhom) else "NA"}
</addressee>
```

#### Asides to the Reader

The text does not call out Mycroft's asides to his gentle reader typographically. I have therefore had to make some editorial choices in marking up those parts of the text which are set like the rest of Mycroft's narration but which I believe to be such an aside using the `<said>` element.

This allows me to include the conversations between Mycroft and the reader in this data, but at the cost of some personal interpretation in what does or does not make the cut.

The rule I've tried to follow is that narration that uses the second person and/or addresses the reader directly should be included. Usually I have found that once this pattern starts it persists to the end of the paragraph. Some individual cases are less clear-cut, and of course I will have made errors during the editing.

### `person`

The unique identifier of a person mentioned by name in the line.

Optional, `NA` indicates no one was mentioned in the line.

Derived from the `ref` parameter of any children `<persName>` nodes of the line, broken out to multiple rows if there is more than one. See `speaker` for format and meaning of the identifier.

```xml
<person>
  {if ($line//tei:persName) then 
    for $name in distinct-values($line//tei:persName/@ref)
    return normalize-space(concat($name, " "))
  else "NA"}
</person>
```

### `org`

The unique identifier of an organization or group mentioned by name in the line.

Optional, `NA` indicates no organization was mentioned in the line.

Derived from the `ref` parameter of any children `<orgName>` nodes of the line, broken out to multiple rows if there is more than one. 

```xml
<org>
  {if ($line//tei:orgName)then 
    for $name in distinct-values($line//tei:orgName/@ref)
    return normalize-space(concat($name, " "))
  else "NA"}
</org>
```

#### Org IDs

The organizations are managed much like the characters, but using `<org>` nodes instead of `<person>`. Unlike persons, orgs can nest.

These include Hives, bash'es, nation strats, the servicers, or the Chicago Museum of Science and Industry with its Junior Scientist Club.

### `place`

The unique identifier of a place mentioned by name in the line.

Optional, `NA` indicates no place was mentioned in the line.

Derived from the `ref` parameter of any children `<placeName>` nodes of the line, broken out to multiple rows if there is more than one. 

```xml
<place>
  {if ($line//tei:placeName) then 
    for $name in distinct-values($line//tei:placeName/@ref)
    return normalize-space(concat($name, " "))
  else "NA"}
</place>
```

#### Place IDs

Places are managed much like orgs, but using `<place>` nodes instead of `<org>`.

These include planets, continents, cities, bash'houses, palaces, or flower trenches.

### `language`

The ISO-code for the language the line is spoken in. 

Required, but the file defaults to `en-en` since Mycroft's typographic conventions allowed a programmatic approach to setting the attribute in the text.

Derived from the `xml:lang` parameter of the line's `<said>` node.

Note that this is _not_ the language of the line in the text itself, since Mycroft takes it upon himself to translate most of the dialog into English. Instead it is inferred from Mycroft's typographical convention to represent the original language via the style of quotation marks used, or sometimes given directly by Mycroft in the narration.

```xml
<language>
  {if ($line/@xml:lang) then data($line/@xml:lang) else "en-en"}
</language>
```

#### Future ISO Language Codes

Several of the languages spoken are future, invented variant of existing ones. In that spirit, I have created fictitious ISO codes for this parameter:

- `en-ar`: archaic English, as used by the reader and Dominic,
- `sp-hu`: Humanist Spanish,
- `jp-mi`: Mitsubishi Japanese, on the premise that Ando makes little distinction betweent voting bloc and strat,
- `fr-eu`: European French,
- `en-tx`: the uncapitalized unpunctuated form of text only english used by eureka weeksbooth
- `la-ma`: Masonic neo-latin.

Others to come as they appear in the text, such as Ute-Speak as a dialect of English. When the text does not imply or affirm otherwise, I have used `en-en` as the language code for default English

#### Non-English Languages in the Text

I have used the `<foreign xml:lang="fr-eu">` element to wrap text that is actually given in a language other than English, e.g. here in European French, but I am not including this information in this data file. Create a feature request on the project GitHub repository if you'd like me to revisit that decision.

### `aloud`

A boolean that indicates whether the line is spoken aloud or not. Takes the value `FALSE` when texting, or between Mycroft and the reader, for example.

Required, but the file defaults to `TRUE` when the attribute has not been set in the text.

Derived from the `aloud` parameter of the line's `<said>` node.

```xml
<aloud>
  {if ($line[@aloud="false"]) then "FALSE" else "TRUE"}
</aloud>
```

### `format`

The style in which the dialog is rendered in the text. Takes the value `script` when the layout changes to a script-like format with the speaker's name repeated at each line, and `novel` otherwise.

Required, `NA` indicates a `<said>` element which does not match the criteria below.

Set to `script` when the ancestor of the line just below the chapter `<div>` level is an `<sp>` node, and to `novel` otherwise.

```xml
<format>
  {if ($line/ancestor::tei:sp) then "script" else "novel"}
</format>
```

### `words`

The number of words in the line.

Required, numeric.

Derived during data cleaning by counting the normalized spaces in the `text` colum, plus one.

```xml
<text>
  {normalize-space(data($line))}
</text>
```

NB: If you have ideas for other columns I could generate from the text without infringing on the author's copyright, please create an issue in the tracker [here](https://github.com/syvwlch/Data-Ignota/issues), or start a new discussion [here](https://github.com/syvwlch/Data-Ignota/discussions).
