[
  {
    "path": "tei/characters/",
    "title": "Characters",
    "description": "The characters in the series, useful for joins to get names, emojis, etc...",
    "author": [
      {
        "name": "Mathieu Glachant",
        "url": {}
      }
    ],
    "date": "2022-10-15",
    "categories": [],
    "contents": "\n\nContents\nOrigins of This Data\nWhat Are <person> Nodes For?\nExample Nodes\n\nGet the Data\nDownload Link\nLast Updated\n\nRaw Data Generation\nXquery Script\nXML Output File\n\nData Prep\nClean: Fix NA Values\nTidy: Separate Delimited Lists\n\nEditing Progress\nNames\nEmojis\n\nData Dictionary\nid\nemoji\nname\nfullName\nsameAs\n\n\nOrigins of This Data\nThis data is generated by extracting all TEI <person> descendant nodes of a <listPerson type=\"characters\"> node in the <standOff> node of the Digital Edition of Terra Ignota.\nWhat Are <person> Nodes For?\nThese <person> nodes contain information about characters in the series. This is metadata added by the editor1, like everything else in <standOff>.\nThe <listPerson type=\"characters\"> node lists persons who are present in the text, “on stage” as it were. This list has sub-lists for convenience in editing, e.g. the Saneer-Weeksbooth ’bash or Danaë’s brood, hence the need to include all descendant <person> nodes, not just children.\nNote that there are other lists of persons in the metadata, e.g. which contain fictional people added as part of world-building or actual historical people referenced in the text. These lists are siblings of the list of characters within <standOff>.\nExample Nodes\nHere’s a simplified view of what these nodes look like:\n<standOff>\n  <listPerson type=\"characters\">\n    <person xml:id=\"Mycroft\">\n      <persName type=\"emoji\">✍<\/persName>\n      <persName type=\"short\">Mycroft<\/persName>\n      <persName type=\"primary\">\n        <forename>Mycroft<\/forename>\n        <surname>Canner<\/surname>\n      <\/persName>\n    <\/person>\n    ...\n  <\/listPerson>\n  ...\n<\/standOff>\nThe data dictionary below maps the information above to a column in the data file.\nGet the Data\nThe data extracted from these <person> nodes is available as a CSV file.\nDownload Link\n\nDownload the data\nLast Updated\nThis file was last updated on 2022-11-03.\nRaw Data Generation\nThe raw data is first extracted from the <person> nodes using an Xquery script.\nXquery Script\nFor easy ingestion with the XML package in R, the script’s output has a <records> root node and one <character> node per character in the original text.\nxquery version \"3.1\";\n\ndeclare namespace tei = \"http://www.tei-c.org/ns/1.0\";\ndeclare variable $doc := doc(\"PATH_TO_TEI_FILE\");\n\n<records>\n  {\n  for $character in $doc//tei:listPerson[@type = \"characters\"]//tei:person\n  return \n  <character>\n    ...\n    A node per column in the output file, see below for details\n    ...\n  <\/character>\n  }\n<\/records>\nXML Output File\nThe Xquery script outputs an XML output file of the form:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<records>\n   <character>\n      <id>#Mycroft<\/id>\n      <emoji>✍<\/emoji>\n      <name>Mycroft<\/name>\n      <fullName>Mycroft Canner<\/fullName>\n      <sameAs>NA<\/sameAs>\n   <\/character>\n   ...\n<\/records>\nData Prep\nThis XML output file must then be cleaned before being saved to the csv file provided above.\nClean: Fix NA Values\nFirst, missing values set to NA. This is very easy using the XML and tidyverse packages.\n\n\ncharacters <- xmlToDataFrame(xml_path) %>%\n  mutate(\n    # Missing values must be _NA_\n    id = na_if(id, \"NA\"),\n    emoji = na_if(emoji, \"NA\"),\n    name = na_if(name, \"NA\"),\n    fullName = na_if(fullName, \"NA\"),\n    sameAs = na_if(sameAs, \"NA\"),\n  )\n\n\nNB: Luckily for you, when you read in this data as a CSV file the readr package is smart enough to correctly guess on all of this.\nTidy: Separate Delimited Lists\nSecond, any rows containing delimited lists2 must be3 separated into multiple rows.\n\n\n\nIn the case of our characters, this would only happen if a <person> node had more than one sameAs alternate identities. There are currently 2 characters with alternate identities but 0 of them have more than one.\n\n\ncharacters <- characters %>%\n  # Break space-delimited columns across multiple rows\n  separate_rows(sameAs, sep = \" \") \n\n\n\n\n\nEditing Progress\nThere are currently 82 characters in the file, including 12 generic ones like ‘unknown Junior Scientist’ or ‘unknown Servicer’.\nNames\nNames are required and there are currently 0 character(s) without one.\nEmojis\nEmojis are optional and there are currently 31 characters with one.\nData Dictionary\nList of the columns in the data file explaining what they mean and how they were generated.\nid\nA unique identifier used within the Digital Edition.\nRequired, unique, must conform to xml:id requirements, e.g. can’t start with a number.\nDerived from parameter xml:id of the <person> node itself, with the # tagged onto the front to match the ref attribute syntax used when pointing to this characters, e.g. in a line of dialog.\n<id>\n  #{data($character/@xml:id)}\n<\/id>\nemoji\nAn emoji evocative of the character, used for visualizations where space is at a premium.\nOptional, unique when it exists.\nDerived from the <persName type=\"emoji\"> child node of the <person> node itself.\n<emoji>\n  {\n  if ($character/tei:persName[@type = \"emoji\"]) \n  then normalize-space(data($character/tei:persName[@type = \"emoji\"]))\n  else \"NA\"\n  }\n<\/emoji>\nname\nA short name for the character, attested in the text.\nAlphanumeric, required. NA means the character has neither short nor full name in the metadata, an omission by the editor.\nDerived from the <persName type=\"short\"> child node of the <person> node itself, or if it does not exist, the full name (see below).\n<name>\n  {\n  if ($character/tei:persName[@type = \"short\"]) \n  then normalize-space(data($character/tei:persName[@type = \"short\"]))\n  else if ($character/tei:persName[@type = \"primary\"]) \n  then normalize-space(data($character/tei:persName[@type = \"primary\"]))\n  else \"NA\"\n  }\n<\/name>\nfullName\nA full name for the character, attested in the book.\nAlphanumeric, required. NA means the character has no full name in the metadata, an omission by the editor.\nDerived from the <persName type=\"primary\"> child node of the <person> node itself.\n<fullName>\n  {\n  if ($character/tei:persName[@type = \"primary\"]) \n  then normalize-space(data($character/tei:persName[@type = \"primary\"]))\n  else \"NA\"\n  }\n<\/fullName>\nsameAs\nThe unique identifier of another character that is actually the same person, aka an alternate identity. Alternate identities result in multiple rows for the same person.\nOptional, NA indicates no alternate identity exists for that person.\nDerived from parameter sameAs of the <person> node itself.\n<sameAs>\n  {\n  if ($character/@sameAs) \n  then data($character/@sameAs)\n  else \"NA\"\n  }\n<\/sameAs>\n\ni.e. yours truly.↩︎\nIn the XML output the lists were space-delimited, since they derived from XML node parameters.↩︎\nIn order to be Tidy Data, in which each row represents a single observation.↩︎\n",
    "preview": {},
    "last_modified": "2022-11-03T10:13:28-04:00",
    "input_file": {}
  },
  {
    "path": "tei/books/",
    "title": "Books",
    "description": "The books in the series, useful for joins to get title, etc...",
    "author": [
      {
        "name": "Mathieu Glachant",
        "url": {}
      }
    ],
    "date": "2022-10-14",
    "categories": [],
    "contents": "\n\nContents\nOrigins of This Data\nWhat Are <text> Nodes For?\nExample Nodes\n\nGet the Data\nDownload Link\nLast Updated\n\nRaw Data Generation\nXquery Script\nXML Output File\n\nData Prep\nClean: Fix Data Types and NA Values\n\nEditing Progress\nData Dictionary\nbook\nid\ntitle\nsubtitle\nbyline\n\n\nOrigins of This Data\nThis data is generated by extracting all TEI <text type=\"book\"> nodes in the Digital Edition of Terra Ignota.\nWhat Are <text> Nodes For?\nThese <text type=\"book\"> nodes contain the text of the novels in the series.\nExample Nodes\nHere’s a simplified view of what these nodes look like:\n<text xml:id=\"TLtL\" type=\"book\" n=\"1\">\n  <front>\n    ...\n    <div>\n      <title type=\"main\">TOO LIKE THE LIGHTNING<\/title>\n      <title type=\"desc\">A Narrative of Events of the year 2454<\/title>\n      <byline>Written by MYCROFT CANNER, at the request of certain parties.<\/byline>\n    <\/div>\n    ...\n  <\/front>\n  <body>\n    <div n=\"1\" type=\"chapter\"><\/div>\n    ...\n  <\/body>\n<text>\nThe data dictionary below maps the information above to a column in the data file.\nGet the Data\nThe data extracted from these <text type=\"book\"> nodes is available as a CSV file.\nDownload Link\n\nDownload the data\nLast Updated\nThis file was last updated on 2022-10-14.\nRaw Data Generation\nThe raw data is first extracted from the <text type=\"book\"> nodes using an Xquery script.\nXquery Script\nFor easy ingestion with the XML package in R, the script’s output has a <records> root node and one <book> node per book in the original text.\nxquery version \"3.1\";\n\ndeclare namespace tei = \"http://www.tei-c.org/ns/1.0\";\ndeclare variable $doc := doc(\"PATH_TO_TEI_FILE\");\n\n<records>\n  {\n  for $book in $doc//tei:text[@type = \"book\"]\n  return \n  <book>\n    ...\n    A node per column in the output file, see below for details\n    ...\n  <\/book>\n  }\n<\/records>\nXML Output File\nThe Xquery script outputs an XML output file of the form:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<records>\n  <book>\n    <book>1<\/book>\n    <id>TLtL<\/id>\n    <title>TOO LIKE THE LIGHTNING<\/title>\n    <subtitle>A Narrative of Events of the year 2454<\/subtitle>\n    <byline>Written by MYCROFT CANNER, at the request of certain parties.<\/byline>\n  <\/book>\n   \n   etc...\n   \n<\/records>\nData Prep\nThis XML output file must then be cleaned before being saved to the csv file provided above.\nClean: Fix Data Types and NA Values\nFirst, the correct data types must be set for each column and missing values set to NA. This is very easy using the XML and tidyverse packages.\n\n\nbooks <- xmlToDataFrame(xml_path) %>%\n  mutate(\n    # Missing values must be _NA_\n    book = na_if(book, \"NA\"),\n    id = na_if(id, \"NA\"),\n    title = na_if(title, \"NA\"),\n    subtitle = na_if(subtitle, \"NA\"),\n    byline = na_if(byline, \"NA\"),\n    # Column data types must be correct\n    book = as.integer(book),\n  )\n\n\nNB: Luckily for you, when you read in this data as a CSV file the readr package is smart enough to correctly guess on all of this.\n\n\n\nEditing Progress\nThere are currently 4 of 4 books present in the Digital Edition.\nData Dictionary\nList of the columns in the data file explaining what they mean and how they were generated.\nbook\nThe number of the book within the series.\nRequired, numeric.\nDerived from parameter n of the <text type=\"book\"> node itself.\n<book>\n  {\n  if ($book/@n) \n  then data($book/@n) \n  else \"NA\"\n  }\n<\/book>\nid\nA unique identifier used within the Digital Edition.\nRequired, unique, must conform to xml:id requirements, e.g. can’t start with a number.\nDerived from parameter xml:id of the <text type=\"book\"> node itself.\n<id>\n  {\n  if ($book/@xml:id) \n  then data($book/@xml:id) \n  else \"NA\"\n  }\n<\/id>\ntitle\nThe title of the book.\nAlphanumeric\nDerived from the content of the child <title type=\"main\"> node of the book’s <front> node.\n<title>\n  {\n  if ($book/tei:front//tei:title[@type = \"main\"]) \n  then data($book/tei:front//tei:title[@type = \"main\"]) \n  else \"NA\"\n  }\n<\/title>\nsubtitle\nThe subtitle of the book.\nAlphanumeric\nDerived from the content of the child <title type=\"desc\"> node of the book’s <front> node.\n<subtitle>\n  {\n  if ($book/tei:front//tei:title[@type = \"desc\"]) \n  then data($book/tei:front//tei:title[@type = \"desc\"]) \n  else \"NA\"\n  }\n<\/subtitle>\nbyline\nThe byline of the book.\nAlphanumeric\nDerived from the content of the child <byline> node of the book’s <front> node.\n<byline>\n  {\n  if ($book/tei:front//tei:byline) \n  then data($book/tei:front//tei:byline) \n  else \"NA\"\n  }\n<\/byline>\n\n\n\n",
    "preview": {},
    "last_modified": "2022-10-14T13:43:03-04:00",
    "input_file": {}
  },
  {
    "path": "tei/chapters/",
    "title": "Chapters",
    "description": "The chapters, useful for joins to get titles, etc...",
    "author": [
      {
        "name": "Mathieu Glachant",
        "url": {}
      }
    ],
    "date": "2022-10-14",
    "categories": [],
    "contents": "\n\nContents\nOrigins of This Data\nWhat Are <div type=\"chapter\"> Nodes For?\nExample Nodes\n\nGet the Data\nDownload Link\nLast Updated\n\nRaw Data Generation\nXquery Script\nXML Output File\n\nData Prep\nClean: Fix Data Types and NA Values\n\nEditing Progress\nToo Like the Lightning\n\nData Dictionary\nbook\nchapter\nnumber\ntitle\neditor\n\n\nOrigins of This Data\nThis data is generated by extracting all TEI <div type=\"chapter\"> child nodes of <body> nodes in the Digital Edition of Terra Ignota.\nWhat Are <div type=\"chapter\"> Nodes For?\nThese <div type=\"chapter\"> nodes contain the text of the chapters in each book.\nExample Nodes\nHere’s a simplified view of what these nodes look like:\n<text type=\"book\" n=\"1\">\n  <body>\n    <div n=\"1\" type=\"chapter\" resp=\"#MaG\">\n      <head type=\"chapterNumber\">Chapter the FIRST<\/head>\n      <head type=\"chapterTitle\">A Prayer to the Reader<\/head>\n      <p>You will criticize me, reader, ...<\/p>\n    ...\n  <\/body>\n<text>\nThe data dictionary below maps the information above to a column in the data file.\nGet the Data\nThe data extracted from these <div type=\"chapter\"> nodes is available as a CSV file.\nDownload Link\n\nDownload the data\nLast Updated\nThis file was last updated on 2022-11-03.\nRaw Data Generation\nThe raw data is first extracted from the <div type=\"chapter\"> nodes using an Xquery script.\nXquery Script\nFor easy ingestion with the XML package in R, the script’s output has a <records> root node and one <chapter> node per chapter in the original text.\nxquery version \"3.1\";\n\ndeclare namespace tei = \"http://www.tei-c.org/ns/1.0\";\ndeclare variable $doc := doc(\"PATH_TO_TEI_FILE\");\n\n<records>\n  {\n  for $chapter in $doc//tei:body//tei:div[@type = \"chapter\"]\n  return \n  <chapter>\n    ...\n    A node per column in the output file, see below for details\n    ...\n  <\/chapter>\n  }\n<\/records>\nXML Output File\nThe Xquery script outputs an XML output file of the form:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<records>\n   <chapter>\n      <book>1<\/book>\n      <chapter>1<\/chapter>\n      <number>Chapter the FIRST<\/number>\n      <title>A Prayer to the Reader<\/title>\n      <editor>#MaG<\/editor>\n   <\/chapter>\n   \n   etc...\n   \n<\/records>\nData Prep\nThis XML output file must then be cleaned before being saved to the csv file provided above.\nClean: Fix Data Types and NA Values\nFirst, the correct data types must be set for each column and missing values set to NA. This is very easy using the XML and tidyverse packages.\n\n\nchapters <- xmlToDataFrame(xml_path) %>%\n  mutate(\n    # Missing values must be _NA_\n    book = na_if(book, \"NA\"),\n    chapter = na_if(chapter, \"NA\"),\n    number = na_if(number, \"NA\"),\n    title = na_if(title, \"NA\"),\n    editor = na_if(editor, \"NA\"),\n    # Column data types must be correct\n    book = as.integer(book),\n    chapter = as.integer(chapter),\n  )\n\n\nNB: Luckily for you, when you read in this data as a CSV file the readr package is smart enough to correctly guess on all of this.\n\n\n\nEditing Progress\nToo Like the Lightning\n\n\n\n      Chapter\n      Edited by\n    1.01\nA Prayer to the Read\n#MaG1.02\nA Boy and His God\n#MaG1.03\nThe Most Important P\n#MaG1.04\nA Thing Long Thought\n#MaG1.05\nAristotle’s House\n#MaG1.06\nRome Was Not Built i\n#MaG1.07\nCanis Domini\n#MaG1.08\nA Place of Honor\n#MaG1.09\nEvery Soul That Ever\n#MaG1.10\nThe Sun Awaits His R\n#MaG1.11\nEnter Sniper\n#MaG1.12\nNeither Earth nor At\n#MaG1.13\n … Perhaps the Stars\n#MaG\n\nData Dictionary\nList of the columns in the data file explaining what they mean and how they were generated.\nbook\nThe number of the book within the series.\nRequired, numeric.\nDerived from parameter n of the <text type=\"book\"> ancestor node of the chapter’s node.\n<book>\n  {\n  data($chapter/ancestor::tei:text[@type = \"book\"]/@n)\n  }\n<\/book>\nchapter\nThe number of the chapter within its book.\nRequired, numeric.\nDerived from parameter n of the chapter node itself.\n<chapter>\n  {\n  if ($chapter/@n) \n  then data($chapter/@n) \n  else \"NA\"\n  }\n<\/chapter>\nnumber\nThe text giving the number of the chapter within its book. This changes over the course of the series.\nAlphanumeric.\nDerived from the content of the child <head type=\"chapterNumber\"> node of the chapter’s node.\n<number>\n  {\n  if ($chapter/tei:head[@type = \"chapterNumber\"]) \n  then data($chapter/tei:head[@type = \"chapterNumber\"]) \n  else \"NA\"  \n  }\n<\/number>\ntitle\nThe title of the chapter.\nAlphanumeric.\nDerived from the content of the child <head type=\"chapterTitle\"> node of the chapter’s node.\n<title>\n  {\n  if ($chapter/tei:head[@type = \"chapterTitle\"]) \n  then data($chapter/tei:head[@type = \"chapterTitle\"]) \n  else \"NA\" \n  }\n<\/title>\neditor\nThe editor responsible for the TEI markup for the chapter.\nAlphanumeric, required. NA indicates editing has not begun for that chapter.\nDerived from the resp attribute of the chapter’s node.\n<editor>\n  {\n  if ($chapter/@resp)\n  then data($chapter/@resp)\n  else \"NA\"\n  }\n<\/editor>\n\n\n\n",
    "preview": {},
    "last_modified": "2022-11-03T10:05:36-04:00",
    "input_file": {}
  },
  {
    "path": "tei/said-element/",
    "title": "`<said>` Element",
    "description": "Who says what and to whom...",
    "author": [
      {
        "name": "Mathieu Glachant",
        "url": {}
      }
    ],
    "date": "2022-10-04",
    "categories": [],
    "contents": "\n\nContents\nOrigins of This Data\nWhat Are <said> Nodes For?\nExample Nodes\n\nGet the Data\nDownload Link\nLast Updated\n\nRaw Data Generation\nXquery Script\nXML Output File\n\nData Prep\nClean: Fix Data Types and NA Values\nTidy: Separate Delimited Lists\nCopyright: Remove Raw Text\n\nEditing Progress\nData Dictionary\nbook\nchapter\nparagraph\nline\npage\nspeaker\naddressee\nperson\norg\nplace\nlanguage\naloud\nformat\nwords\n\n\nOrigins of This Data\nThis data is generated by extracting all TEI <said> nodes in the Digital Edition of Terra Ignota.\nWhat Are <said> Nodes For?\nThese <said> nodes contain the text of all direct communication between characters. I usually refer to such passages as a ‘line of dialog’ or ‘line’ for short.\nExample Nodes\nA line between Mycroft and Dominic would be encoded thus:\nNovel Layout\n<p>\n  <said>\"Where hast thou been, stray?\"<\/said>, Dominic\n  snarled. <said>\"Thy master needs thee.\"<\/said>\n<\/p>\nScript Layout\n<sp>\n  <speaker>Child:<\/speaker>\n  <said>\"I miss you, Mycroft.\"<\/said>\n<\/sp>\nNote that the narration part of that paragraph is always left outside of the node.\nThe data dictionary below maps each piece of information available for the line, e.g. book, chapter, and page or who is speaking, to whom, about what, etc…\nGet the Data\nThe data extracted from these <said> nodes is available as a CSV file.\nDownload Link\n\nDownload the data\nLast Updated\nThis file was last updated on 2022-11-03.\nRaw Data Generation\nThe raw data is first extracted from the <said> nodes using an Xquery script.\nXquery Script\nFor easy ingestion with the XML package in R, the script’s output has a <records> root node and one <line> node per line of dialog in the original text.\nxquery version \"3.1\";\n\ndeclare namespace tei = \"http://www.tei-c.org/ns/1.0\";\ndeclare variable $doc := doc(\"PATH_TO_TEI_FILE\");\n\n<records>\n  {\n  for $book in $doc//tei:text[@type = \"book\"]\n    for $chapter in $book//tei:div[@type = \"chapter\"]\n      for $p at $p_index in $chapter//(tei:p | tei:sp)\n        for $line at $line_index in $p//tei:said\n  <line>\n    ...\n    A node per column in the output file, see below for details\n    ...\n  <\/line>}\n<\/records>\nThe query iterates thru books, chapters, paragraphs, and lines of dialog. The first two levels are numbered in the original file, but the lower two are numbered during data extraction, hence their need for an index.\nXML Output File\nThe Xquery script outputs an XML output file of the form:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<records>\n   <line>\n      <book>1<\/book>\n      <chapter>1<\/chapter>\n      <paragraph>1<\/paragraph>\n      <line>1<\/line>\n      <page>13<\/page>\n      <speaker>#Mycroft<\/speaker>\n      <addressee>#reader<\/addressee>\n      <person>#reader<\/person>\n      <org>NA<\/org>\n      <place>NA<\/place>\n      <language>en-en<\/language>\n      <aloud>FALSE<\/aloud>\n      <format>novel<\/format>\n      <text>You will criticize me, reader, for ... <\/text>\n   <\/line>\n   \n   etc...\n   \n<\/records>\nData Prep\nThis XML output file must then be cleaned, tidied, and purged of content under copyright before being saved to the csv file provided above.\nClean: Fix Data Types and NA Values\nFirst, the correct data types must be set for each column and missing values set to NA. This is very easy using the XML and tidyverse packages.\n\n\nsaid <- xmlToDataFrame(xml_path) %>%\n  mutate(\n    # Column data types must be correct\n    book = as.integer(book),\n    chapter = as.integer(chapter),\n    paragraph = as.integer(paragraph),\n    line = as.integer(line),\n    page = as.integer(page),\n    aloud = as.logical(aloud),\n    # Missing values must be _NA_\n    speaker = na_if(speaker, \"NA\"),\n    addressee = na_if(addressee, \"NA\"),\n    person = na_if(person, \"NA\"),\n    org = na_if(org, \"NA\"),\n    place = na_if(place, \"NA\")\n  )\n\n\nNB: Luckily for you, when you read in this data as a CSV file the readr package is smart enough to correctly guess on all of this.\nTidy: Separate Delimited Lists\nSecond, any rows containing delimited lists1, e.g. a line of dialog with more than one addressee, must be2 separated into multiple rows.\n\n\nsaid <- said %>%\n  # Break space-delimited columns across multiple rows\n  separate_rows(speaker, sep = \" \") %>%\n  separate_rows(addressee, sep = \" \") %>%\n  separate_rows(person, sep = \" \") %>%\n  separate_rows(org, sep = \" \") %>%\n  separate_rows(place, sep = \" \") \n\n\nCopyright: Remove Raw Text\nLastly, before writing to the CSV file, any text under copyright is removed. This is the last chance to process that text, so let’s add a words column for the number of words in the line.\n\n\nsaid <- said %>%\n  # Proxy for word count, counting spaces as separators\n  mutate(words = str_count(text, \" \") + 1)  %>%\n  # Must not include the original text for copyright reasons\n  mutate(text = NULL)\n\n\n\n\n\nNB: If you have ideas for other columns I could generate from the text at this step, please create an issue in the tracker here, or start a new discussion here.\nEditing Progress\n\n\nChapter1\n      Progress2\n      \n        Missing Param.\n      \n    speaker\n      addressee\n    1.01\n100%\n-\n-1.02\n100%\n-\n-1.03\n100%\n-\n-1.04\n100%\n-\n-1.05\n100%\n-\n-1.06\n100%\n-\n-1.07\n100%\n-\n-1.08\n100%\n-\n-1.09\n100%\n-\n-1.10\n100%\n-\n-1.11\n100%\n-\n-1.12\n100%\n-\n-1.13\n100%\n-\n-1 Chapters with at least one line edited.\n    2 Percentage of lines edited.\n    \n\nData Dictionary\nList of the columns in the data file explaining what they mean and how they were generated.\nbook\nThe number of the book which contains the line.\nRequired, numeric.\nDerived from parameter n of the <text type=\"book\"> node the line is a child of.\n<book>\n  {data($book/@n)}\n<\/book>\nchapter\nThe number of the chapter containing the line.\nRequired, numeric.\nDerived from parameter n of the <div type=\"chapter\"> node the line is a child of.\n<chapter>\n  {data($chapter/@n)}\n<\/chapter>\nparagraph\nThe number of the paragraph (within the chapter) of the paragraph containing the line.\nRequired, numeric.\nDerived from the index $p_index generated while iterating in document order thru the <p> and <sp> children of the current chapter.\n<paragraph>\n  {$p_index}\n<\/paragraph>\nline\nThe number of the actual line of dialog within the current paragraph.\nRequired, numeric.\n<line>\n  {$line_index}\n<\/line>\nIf there are more than one line of dialog for a paragraph, this usually indicates that there is some narration separating them. The paragraph below contains two lines of dialog, for example.\n<p>\n  <said>\"Where hast thou been, stray?\"<\/said>, Dominic\n  snarled. <said>\"Thy master needs thee.\"<\/said>\n<\/p>\npage\nThe number of the page on which the line starts.\nRequired, numeric.\nDerived from parameter n of the <pb/> milestone node which precedes the line in document order.\n<page>\n  {data($line/preceding::tei:pb[1]/@n)}\n<\/page>\nspeaker\nThe unique identifier of the character speaking the line. Multiple speakers result in multiple rows for the same line.\nRequired, NA indicates the line needs to be edited.\nDerived from parameter who of the line’s <said> node.\n<speaker>\n  {if ($line/@who) then data($line/@who) else \"NA\"}\n<\/speaker>\nCharacter IDs\nThe identifier takes the form #Mycroft or #Carlyle. It points to a unique <person> node with the xml:id parameter set to that value.\nThose <person> nodes contain metadata about the character, e.g. names, affiliations, age, etc… and are stored outside the text in a <standoff> node within the Digital Edition’s file.\nI will, at some point, publish the list of characters as its own file and the primary key will be this identifier to permit joins.\n‘Unknown’ Characters\nIt is not always clear in the text who is speaking, e.g. when Carlyle first overhears thru Thisbe’s door in Chapter the First, or the speaker is an unnamed individual in a crowd or group, e.g. the several servicers who witness Vivien dragging Mycroft out of the gutter in Chapter the Sixth.\nFor such cases, I use generic IDs with the form #Unknown-Soldier or #Unknown-Servicer or the fallback #Unknown.\naddressee\nThe unique identifier of the character the line is being spoken to. Multiple addressees result in multiple rows for the same line.\nRequired, NA indicates the line needs to be edited.\nDerived from the parameter toWhom of the line’s <said> node.\nSee speaker for format and meaning of the identifier.\n<addressee>\n  {if ($line/@toWhom) then data($line/@toWhom) else \"NA\"}\n<\/addressee>\nAsides to the Reader\nThe text does not call out Mycroft’s asides to his gentle reader typographically. I have therefore had to make some editorial decisions when marking up those parts of the text which are typeset like narration but which I believe to be such an aside.\nThis allows me to include the conversations between Mycroft and the reader in this data, but at the cost of some personal interpretation in what does or does not make the cut.\nThe rule I’ve tried to follow is that narration that uses the second person and/or addresses the reader directly should be included. Usually I have found that once this pattern starts it persists to the end of the paragraph. Some individual cases are less clear-cut, and of course I will have made errors during the editing.\nperson\nThe unique identifier of a person mentioned by name in the line. Multiple people mentioned result in multiple rows for the same line.\nOptional, NA indicates no one was mentioned in the line.\nDerived from the ref parameter of any children <persName> nodes of the line.\nSee speaker for format and meaning of the identifier.\n<person>\n  {if ($line//tei:persName) then \n    for $name in distinct-values($line//tei:persName/@ref)\n    return normalize-space(concat($name, \" \"))\n  else \"NA\"}\n<\/person>\norg\nThe unique identifier of an organization or group mentioned by name in the line. Multiple orgs mentioned result in multiple rows for the same line.\nOptional, NA indicates no organization was mentioned in the line.\nDerived from the ref parameter of any children <orgName> nodes of the line,.\n<org>\n  {if ($line//tei:orgName)then \n    for $name in distinct-values($line//tei:orgName/@ref)\n    return normalize-space(concat($name, \" \"))\n  else \"NA\"}\n<\/org>\nOrg IDs\nThe organizations are managed much like the characters, but using <org> nodes instead of <person>. Unlike persons, orgs can nest.\nThese include Hives, bash’es, nation strats, the servicers, or the Chicago Museum of Science and Industry as well as its Junior Scientist Club.\nplace\nThe unique identifier of a place mentioned by name in the line. Multiple places mentioned result in multiple rows for the same line.\nOptional, NA indicates no place was mentioned in the line.\nDerived from the ref parameter of any children <placeName> nodes of the line.\n<place>\n  {if ($line//tei:placeName) then \n    for $name in distinct-values($line//tei:placeName/@ref)\n    return normalize-space(concat($name, \" \"))\n  else \"NA\"}\n<\/place>\nPlace IDs\nPlaces are managed much like orgs, but using <place> nodes instead of <org>.\nThese include planets, continents, cities, bash’houses, palaces, or flower trenches and they nest as well.\nlanguage\nThe ISO-code for the language the line is spoken in.\nRequired, but the output file defaults to en-en since Mycroft’s typographic conventions allowed a programmatic approach to setting the attribute in the text.\nDerived from the xml:lang parameter of the line’s <said> node.\nNote that this is not the language of the line in the text itself, since Mycroft takes it upon himself to translate most of the dialog into English.\n<language>\n  {if ($line/@xml:lang) then data($line/@xml:lang) else \"en-en\"}\n<\/language>\nFuture ISO Language Codes\nSeveral of the languages used are future invented variants of current ones. In that spirit, I have created fictitious ISO codes for this parameter:\nen-ar: archaic English, as used by the reader and Dominic,\nsp-hu: Humanist Spanish,\njp-mi: Mitsubishi Japanese, on the premise that Ando makes little distinction between voting bloc and nation-strat,\nfr-eu: European French, just to piss of Ganymede,\nen-tx: the uncapitalized unpunctuated form of text only english used by eureka weeksbooth\nla-ma: Masonic neo-latin.\nOthers to come as they appear in the text, such as Ute-Speak as a dialect of English.\nNon-English Languages in the Text\nI have used the <foreign xml:lang=\"fr-eu\"> element to wrap text that is actually given in a language other than English but I am not including this information in this data file. Create a feature request on the project GitHub repository if you’d like me to revisit that decision.\naloud\nA boolean indicating whether the line is spoken aloud or not. Takes the value FALSE when texting or between Mycroft and the reader, for example.\nRequired, but the file defaults to TRUE when the attribute has not been set in the text.\nDerived from the aloud parameter of the line’s <said> node.\n<aloud>\n  {if ($line[@aloud=\"false\"]) then \"FALSE\" else \"TRUE\"}\n<\/aloud>\nformat\nThe style in which the dialog is rendered in the text. Takes the value script when the layout changes to a script-like format with the speaker’s name repeated at each line, and novel otherwise.\nRequired, NA indicates a <said> element which does not match the criteria below.\nSet to script when the ancestor of the line just below the chapter <div> level is an <sp> node, and to novel otherwise.\n<format>\n  {if ($line/ancestor::tei:sp) then \"script\" else \"novel\"}\n<\/format>\nwords\nThe number of words in the line.\nRequired, numeric.\nDerived during data cleaning by counting the normalized spaces in the text column, plus one.\n<text>\n  {normalize-space(data($line))}\n<\/text>\nNB: If you have ideas for other columns I could generate from the text without infringing on the author’s copyright, please create an issue in the tracker here, or start a new discussion here.\n\nIn the XML output the lists were space-delimited, since they derived from XML node parameters.↩︎\nIn order to be Tidy Data, in which each row represents a single observation.↩︎\n",
    "preview": {},
    "last_modified": "2022-11-03T11:19:00-04:00",
    "input_file": {}
  },
  {
    "path": "tei/tei-structure/",
    "title": "TEI - High Level Structure",
    "description": "A map of where all this data comes from...",
    "author": [
      {
        "name": "Mathieu Glachant",
        "url": {}
      }
    ],
    "date": "2022-10-02",
    "categories": [],
    "contents": "\n\nContents\nStructure of a TEI Edition\nMetadata and Text (Required)\nStandoff (Optional)\n\nSeries As One File\nSeries vs. Novels\nContents of a Novel\n\nPutting It Together\nHigh-Level Structure\n\n\nStructure of a TEI Edition\nThis project rests on a personal digital edition of the Terra Ignota series. All of the analyses use data that ultimately come from a single file containing the text of all four books marked up in a dialect of XML called TEI1.\nThis article explains the high-level structure of that file and serves as an orientation for those interested in where the data lives in relation to the text itself. Other articles in this collection will drill down into specific XML elements from the TEI schema.\nMetadata and Text (Required)\nAll TEI documents must have the following structure:\n<TEI xmlns=\"http://www.tei-c.org/ns/1.0\">\n  <teiHeader>\n    Metadata about this Digital Edition\n  <\/teiHeader>\n  <text>\n    Ada Palmer's text(s)\n  <\/text>\n<\/TEI>\nThe root is a <TEI> node with a xmlns parameter that declares the schema. The metadata about the file itself goes into the required <teiHeader> element (sources, editorial and encoding decisions, change control, contributors, etc…) and the text(s) go into the aptly named <text> node.\nStandoff (Optional)\nI have also included an optional <standoff> node. This contains anything I want to add alongside the text to support my analysis, while keeping them separate:\n<TEI xmlns=\"http://www.tei-c.org/ns/1.0\">\n  <teiHeader>\n    Metadata about this Digital Edition\n  <\/teiHeader>\n  <standoff>\n    My many long lists of things, people, places, and events I'm tracking\n  <\/standoff>\n  <text>\n    Ada Palmer's text(s)\n  <\/text>\n<\/TEI>\nThis is particularly useful to create lists of <person>,<place>, <object>, or <event> nodes which I can then point to from within the text, e.g. each time a character is mentioned, I can mark that mention with a <persName> tag pointing to that character’s <person> entry in <standoff>, to disambiguate who is being referred to:\n<standoff>\n  <person xml:id=\"Mycroft\">\n    <name>Mycroft Canner<\/name>\n  <\/person>\n<\/standoff>\n<text>\n  ....\n  \"Where hast thou been, <persName ref=\"#Mycroft\">stray<\/persName>?\"\n  ....\n<\/text>\nSeries As One File\nI opted to group the four novels into a single file to simplify data retrieval and analysis across the series. I may change this later if the file just gets too cumbersome.\nSeries vs. Novels\nBecause Terra Ignota is a series, I have structured the contents of the top-level <text> node as a <group> node for the series containing a child <text> node for each novel. Each of these nodes has a a unique xml:id parameter we can query or point to.\n<text>\n  <group xml:id=\"TerraIgnota\">\n    <text xml:id=\"TooLikeTheLightning\"><\/text>\n    <text xml:id=\"SevenSurrenders\"><\/text>\n    <text xml:id=\"TheWillToBattle\"><\/text>\n    <text xml:id=\"PerhapsTheStars\"><\/text>\n  <\/group>\n<\/text>\nContents of a Novel\nLastly, I have broken down each novel into different nodes for the front matter, the main body of the text, and the back matter. The <front> node contains the title page, the dedication, epigraph, and permissions, the <body> node contains the chapters, and the <back> node contains the acknowledgments, author bio, etc…\n<text xml:id=\"TooLikeTheLightning\">\n  <front>\n    Dedication\n    Permissions\n    Epigraph\n    Title Page\n  <\/front>\n  <body>\n    Chapter the First\n    Chapter the Second\n    etc...\n  <\/body>\n  <back>\n    Acknowledgments\n    Author's Bio\n    Copyright Notice\n  <\/back>\n<\/text>\nPutting It Together\nHigh-Level Structure\nPutting it all together, we get the following structure against which to run our queries to extract that sweet, sweet data:\n<TEI xmlns=\"http://www.tei-c.org/ns/1.0\">\n  <teiHeader>\n    Metadata about this Digital Edition\n  <\/teiHeader>\n  <standoff>\n    My many long lists of things, people, places, and events I'm tracking\n  <\/standoff>\n  <text>\n    <group xml:id=\"TerraIgnota\">\n      <text xml:id=\"TooLikeTheLightning\">\n        <front><\/front>\n        <body><\/body>\n        <back><\/back>\n      <\/text>\n      <text xml:id=\"SevenSurrenders\">\n        <front><\/front>\n        <body><\/body>\n        <back><\/back>\n      <\/text>\n      <text xml:id=\"TheWillToBattle\">\n        <front><\/front>\n        <body><\/body>\n        <back><\/back>\n      <\/text>\n      <text xml:id=\"PerhapsTheStars\">\n        <front><\/front>\n        <body><\/body>\n        <back><\/back>\n      <\/text>\n    <\/group>\n  <\/text>\n<\/TEI>\n\nText Encoding Initiative: https://tei-c.org/↩︎\n",
    "preview": {},
    "last_modified": "2022-10-07T10:23:36-04:00",
    "input_file": {}
  }
]
